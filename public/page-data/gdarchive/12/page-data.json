{"componentChunkName":"component---src-templates-blog-post-js","path":"/gdarchive/12","webpackCompilationHash":"693ae2210e6ed9f2aeb9","result":{"data":{"markdownRemark":{"html":"<p>One thing I really slacked on while developing GreaterDebater was\ntesting. Maybe that's not the right way to put it. It's not like I\n<em>didn't</em> test. In fact, I did a lot of testing. A lot of painstaking\nmanual testing. For every change. So, in a way it was really the\nopposite of slacking. It was working a whole lot harder than I really\nneeded to. It was also dumb. What I did slack on, was figuring out how\nDjango's unit testing framework worked. Well, no more! In fact, it's\nreally easy to set up. Writing tests can also be somewhat painstaking\nwhen it comes to ensuring you've covered every possible input, but at\nleast that pain is an investment that repays itself every time you make\na change to the program and you can know right away if you've broken\nsomething that used to work.  </p>\n<p>As usual the\n<a href=\"http://docs.djangoproject.com/en/dev/topics/testing/#topics-testing\">Django documentation</a>\nis excellent. I highly recommend it for learning everything there is\nto know about testing with Django. What I hope to do here is give a\nbrief overview of what you need to do some basic testing. Partly as a\nreminder for myself on future projects, and hopefully to help out\nanyone in the same position I was before I started.</p>\n<h2>Getting Started</h2>\n<p>If your Django app is relatively new, the startapp command already\ncreated a tests.py file when you ran it to set up your app. This file includes some\nhelpful examples, like so:</p>\n<pre><code>\"\"\"\nThis file demonstrates two different styles of tests (one doctest and one\nunittest). These will both pass when you run \"manage.py test\".\n\nReplace these with more appropriate tests for your application.\n\"\"\"\n\nfrom django.test import TestCase\n\nclass SimpleTest(TestCase):\n    def test_basic_addition(self):\n        \"\"\"\n        Tests that 1 + 1 always equals 2.\n        \"\"\"\n        self.failUnlessEqual(1 + 1, 2)\n\n__test__ = {\"doctest\": \"\"\"\nAnother way to test that 1 + 1 is equal to 2.\n\n>>> 1 + 1 == 2\nTrue\n\"\"\"}    \n</code></pre>\n<p>If you don't already have a tests.py file, the important things to\nnote are that you have to import the <strong>TestCase</strong> class from\ndjango.test and create a new class which subclasses it. Each method\ndefined in this class will correspond to one test, usually the test of\na corresponding function in your <strong>views.py</strong> file. To test a\nparticular function from <strong>views.py</strong>, define a method with the name\n<strong>test_functionname</strong>.</p>\n<h2>Test data</h2>\n<p>Now, I'm guessing your application probably manipulates some sort of\ndata. The Django test runner is kind enough to setup and destroy a\ncomplete test database for the purposes of running your tests. There's\ntwo important consequences to this. First, the database user specified\nin your settings.py file has to have the necessary permissions to\ncreate and destroy databases. So, make sure that's the case.  Second,\nif you already have a test database set up on your development machine\n(or wherever), with data you've inserted during your manual tests, the\ntest runner won't have access to any of it.</p>\n<p>To get some data for your tests, you can try exporting the data\nalready in your test database with Django's dumpdata command. The test\nrunner can then load it as a\n<a href=\"http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading\">fixture</a>.\nHonestly, I just couldn't get this to work. Some googling about the\nerrors I was getting seemed to indicate that I wasn't the only one\nhaving problems with it. The update to\n<a href=\"http://djangoadvent.com/1.2/natural-keys/\">natural keys</a> announced\nfor Django 1.2 seemed like it would help, but I've still been\nunsuccessful, so far. In any event, I plan on keeping an eye on future\ndevelopments to see if there's any improvements in this area.</p>\n<p>In the meantime, I went ahead and did it the hard way. I created a\nseparate file called <strong>testsetup.py</strong>. I imported all the models for\nmy project and defined a function also called <strong>testsetup</strong>. All this\nfunction does is create a few instances for each model with all their\nvarious possible configurations. By defining a method called <strong>setUp</strong>\nin the new class I created in <strong>tests.py</strong> and calling this function\nthere, all of the necessary data will be added to the test database\nbefore the tests are run.</p>\n<pre><code>class ViewTest(TestCase):\n\n    def setUp(self):\n        testsetup()\n</code></pre>\n<h2>GET Requests</h2>\n<p>The easiest of your views to test are the ones that only handle GET\nrequests. All you have to do is retrieve the correct item from the\ndatabase and display the information. Let's use the canonical\nbook/author/publisher example. Suppose we're testing a view that\ndisplays the details for a particular book.</p>\n<pre><code>def test_book_detail(self):\n    testbook = Book.objects.all()[0]\n    url = '/books/id/' + str(testbook.id)\n    response = self.client.get(url)\n    self.assertContains(response, testbook.title)\n</code></pre>\n<p>The first thing I want to stress, is that I think it's important that\nno specific test data is used in the tests. Always try to select\nobjects you're going to use for your tests in a generic way. This way\nit won't matter how your test data gets moved around or changed over\ntime. In this example I just picked the first book returned in the\nqueryset for all books. What you <em>don't</em> want to do is something like this:</p>\n<pre><code>testbook = Book.objects.get(title=\"The Test Book\")\n</code></pre>\n<p>That assumes your test database has a book with that title in it,\nwhich it may or may not. Over time it's bound to get mighty confusing\ntrying to keep the data in your test database synchronized with the\ndata in your tests, so it's best to save yourself the headache.</p>\n<p>The Django <strong>TestCase</strong> class comes with a built in client to make all\nyour requests. For a GET request all you have to do is pass it a URL\nand it will return the response generated by that request. The\n<strong>TestCase</strong> class also defines some new\n<a href=\"http://docs.djangoproject.com/en/1.1/topics/testing/#assertions\">assertions</a>\nin addition to the standard ones Python provides. <strong>assertContains</strong>,\nused in this example, takes a response object and verifies that it has\na particular piece of text in it; in this case, the book's\ntitle. Optionally, you can specify a particular response code, and\nnumber of repititions for the piece of text. If you're expecting a\nparticular url to not be found you might test:</p>\n<pre><code>badurl = '/books/id/notabookid'\nresponse = self.client.get(badurl)\nself.assertContains(response, \"Book not found\", status_code=404)\n</code></pre>\n<h2>POST requests</h2>\n<p>Of course all of this data has to get into your database somehow. You\nknow you don't want to put it all there yourself, so you're probably\ngoing to have your users do it. This likely means you'll have some\nforms on your site that you want them to submit. For our example,\nlet's pretend authors are submitting their own books to the\nsite. Let's assume a few things about how this function works, so we\nknow what we're testing.</p>\n<ul>\n<li>The user must be logged in to submit a book</li>\n<li>A book requires a title, an author, and an ISBN field</li>\n<li>Upon successfully submitting a book, we want to redirect the user to\nthe detail page for that book.</li>\n<li>The ID field for the <strong>Book</strong> model is auto-incremented (Django's default)</li>\n</ul>\n<p>Simple enough, right? Django provides all the tools you need to test\nevery aspect of this function.</p>\n<pre><code>def test_addbook(self):\n    url = '/books/add/'\n\n    author = Author.objects.all()[0]    \n    user = author.user\n\n    # User not logged in\n    response = self.client.get(url)\n    self.assertEqual(response.status_code, 403)\n\n    self.client.login(username=user.username, password='password')\n\n    # Valid user\n    response = self.client.get(url)\n    self.assertEqual(response.status_code, 200)\n\n\n    # Invalid Form\n    response = self.client.post(url, {'title': \"Book Title\",\n                                      'author_id': author.id,\n                                      'ISBN': \"invalid ISBN\"})\n    self.assertFormError(response, \n                         \"BookSubmitForm\", \n                         'ISBN',\n                         \"ISBN field must contain a number\")\n\n    # Valid submission\n    newid = Book.objects.aggregate(Max('id'))['id__max'] + 1\n    redirect = '/books/id/%d' % newid\n    response = self.client.post(url, {'title': \"Test book\",\n                                      'author_id': author.id,\n                                      'ISBN': 123456},\n                                      follow=True)\n\n    self.assertRedirects(response, redirect)\n    self.assertContains(response, \"Test book\")\n</code></pre>\n<p>First you'll want to test a GET request for the url, to make sure the\nuser can see the form properly to fill it in. Also check that the form\nis not visible to users who aren't logged in. In this case, that means\nsimply making sure the response returns a 403 Forbidden status\ncode. To log in as a user, simply use the <strong>self.client.login</strong>\nfunction with the appropriate name and password. It's easy enough to\npull a random user from the ones you set up in the <strong>testsetup</strong>\nfunction, but I've violated my own rule a little by specifying a value\nfor the user's password. In fact, I'm not sure there's any other way\nto do this. For the sake of simplicity, I'm just giving all of the\nusers created in <strong>testsetup</strong> the same password.  For POST requests,\nsimply add a dictionary with all the required form fields and\nvalues. You can make sure the form validation is catching errors\nproperly by submitting an invalid form and using the\n<strong>assertFormError</strong> assertion to verify that the appropriate form\nvalidation error occurs. This assertion takes 4 arguments: the\nresponse, the name the template uses for the form, the form field in\nquestion, and the error text (or a list of strings for multiple\nerrors) that is expected. Finally, since the id for new books is just\nautoincremented, we can assume the id for the book we create will be\none more than highest one in the database yet. By plugging this into\nthe book detail url, we have the address of the page we'll be\nredirected to when the book is successfully submitted. If you want to\nuse <strong>assertContains</strong> or anything else to check the contents of the\nfinal page you get redirected to, be sure to add <strong>follow=True</strong> in\nthe post function. This way it will return the final response, not the\nintermediate redirect response.</p>\n<p>I suppose now is a good time to mention that the Django test runner\nwill return the database to its original state (after populated by the\n<strong>setUp</strong> method) after each test. That means that any\nbooks you add during the <strong>test__addbook</strong> method will be deleted when\nthat test is over. You won't have access to them in, for example,\n<strong>test_deletebook</strong> that you might write afterwards, so keep that in mind.</p>\n<p>I hope this has been a helpful introduction to Django's testing\nfacilities. I've only scratched the surface of what it can do, but I\nthink it's a good place to start. Like I said, the\n<a href=\"http://docs.djangoproject.com/en/dev/topics/testing/#topics-testing\">documentation</a>\nis up to Django's usual high standards, so definitely make the most of\nit.</p>\n<p>Happy Testing!</p>\n<p><em>Originally published 2010-04-05 06:50:17</em></p>","frontmatter":{"date":"2010-04-05","path":"/gdarchive/12","title":"A Django Unit Testing Primer"}},"site":{"siteMetadata":{"title":"KotSF"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}