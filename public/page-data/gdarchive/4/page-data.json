{"componentChunkName":"component---src-templates-blog-post-js","path":"/gdarchive/4","webpackCompilationHash":"693ae2210e6ed9f2aeb9","result":{"data":{"markdownRemark":{"html":"<p>Finding a url inside a chunk of text is no easy task.\n<a href=\"http://www.codinghorror.com/blog/archives/001181.html\">Coding Horror</a>\nand <a href=\"http://daringfireball.net/2009/11/liberal_regex_for_matching_urls\">Daring Fireball</a>\nhave covered regular expressions for matching urls in a variety of\ncircumstances. I went with the Coding Horror regular expression, mainly because the Daring Fireball version\nwasn't around when I was working on this. Using Python's regular expression library, the code to get all the urls in a block of text looks like this:</p>\n<pre><code>urlre = re.compile(\"(\\(?https?://[-A-Za-z0-9+&#x26;@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&#x26;@#/%=~_()|])(\\\">|&#x3C;/a>)?\")\nurls = urlre.findall(html)\n</code></pre>\n<p>That pulls out all of the urls in a text and puts them in a list. From\nthere you can iterate through the list and replace the url in the\nsource text with the appropriate html.</p>\n<p>But that only works if you're only allowing plain text as\ninput. What if you're using markdown for formatting? In this case\nthere might be urls in the text that are already a part of a link. You don't want to add additional html around these or you'll break the user's formatting. There's two ways you could go, I suppose. You could either process the text before you send it to the markdown processor and add markdown formatting around the urls, or you could look at the html output you get and find the bare urls in that. I went with the latter option. This way the function isn't tied to markdown specifically, and it's useful in more applications.</p>\n<p>The obvious case you want to avoid is where the user has entered a\nnormal link as markdown. In that case, the markdown formatting will take care of adding the appropriate html.</p>\n<pre><code>&#x3C;a href=\"http://example.com\">link&#x3C;/a>\n</code></pre>\n<p>But maybe some helpful user has used markdown to link a url for us.\nThat will output some html like this:</p>\n<pre><code>&#x3C;a href=\"http://example.com\">http://example.com&#x3C;/a>\n</code></pre>\n<p>In this case we want to ignore both instances of the url.   </p>\n<p>Finally, you have to account for the sadistic case. This is the\npossibility that someone will make a regular markdown link with a\ngiven url, then paste in that <em>same</em> url elsewhere in the text. You\nhave to ignore the instance where it's linked legitimately, but catch\nthe instance where it's a bare url and turn it into a link. The\nresulting html will look like this:</p>\n<pre><code>&#x3C;a href=\"http://example.com\">http://example.com&#x3C;/a>\n...\n...\nhttp://example.com\n</code></pre>\n<p>There are two steps to solve this. The first part is the regular expression\nshown above. This actually has two groups. The first group</p>\n<pre><code>(\\(?https?://[-A-Za-z0-9+&#x26;@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&#x26;@#/%=~_()|])\n</code></pre>\n<p>matches the url while the second group</p>\n<pre><code>(\\\">|&#x3C;/a>)?\n</code></pre>\n<p>matches either \"> or &#x3C;/a> after the url, if they're\npresent. When your regular expression has multiple groups urlre.findall returns a list of tuples. The first element of the tuple contains the matched url. There will be an entry in the list for every occurrence of a url in the text, with duplicates included. The second element in the tuple will be either \"> or &#x3C;/a> if they are present immediately after the url. If the second element is not an empty string, we know the url is already part of a link, so we\ncan ignore it.</p>\n<p>Then there's the sadistic case to contend with. You want to replace a url with a link <em>only</em> when it's not preceded by =\" or \">. Instead of using the simple string replace function, the substitute function from the regular expressions library will allow us to only replace certain instances of the url. A negative lookbehind will ensure that the url is replaced only when it's not already part of a link.</p>\n<p>The complete autolink function is shown below.</p>\n<pre><code>def autolink(html):\n    # match all the urls\n    # this returns a tuple with two groups\n    # if the url is part of an existing link, the second element\n    # in the tuple will be \"> or &#x3C;/a>\n    # if not, the second element will be an empty string\n    urlre = re.compile(\"(\\(?https?://[-A-Za-z0-9+&#x26;@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&#x26;@#/%=~_()|])(\\\">|&#x3C;/a>)?\")\n    urls = urlre.findall(html)\n    clean_urls = []\n\n    # remove the duplicate matches\n    # and replace urls with a link\n    for url in urls:\n        # ignore urls that are part of a link already\n        if url[1]: continue\n        c_url = url[0]\n        # ignore parens if they enclose the entire url\n        if c_url[0] == '(' and c_url[-1] == ')':\n            c_url = c_url[1:-1]\n    \n        if c_url in clean_urls: continue # We've already linked this url\n\n        clean_urls.append(c_url)\n        # substitute only where the url is not already part of a\n        # link element.\n        html = re.sub(\"(?&#x3C;!(=\\\"|\\\">))\" + re.escape(c_url), \n                      \"&#x3C;a rel=\\\"nofollow\\\" href=\\\"\" + c_url + \"\\\">\" + c_url + \"&#x3C;/a>\",\n                      html)\n    return html\n</code></pre>\n<p>Hopefully, a later version of markdown will have autolinking baked right in. If you're using <a href=\"http://github.github.com/github-flavored-markdown/\">GitHub Flavored Markdown</a>, you've already got it. I haven't seen a Python implementation for that yet, though.</p>\n<p><em>Originally published 2010-02-08 08:07:17</em></p>","frontmatter":{"date":"2010-02-08","path":"/gdarchive/4","title":"So you want to autolink urls..."}},"site":{"siteMetadata":{"title":"KotSF"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}