{"componentChunkName":"component---src-templates-blog-post-js","path":"/gdarchive/7","webpackCompilationHash":"693ae2210e6ed9f2aeb9","result":{"data":{"markdownRemark":{"html":"<p>Python is the language of one, and only one, obvious way to do\nthings. This isn't quite the case when it comes to concatenating\nstring though. There's three obvious choices. First, you can use the +\noperator. Since strings are considered a sequence type, along with\nlists and tuples, this works just like you would expect:</p>\n<pre><code>>>> str1, str2, str3 = 'abc', 'def', 'ghi'\n>>> str1 + str2 + str3\n'abcdefghi'\n</code></pre>\n<p>String formatting is also an option. This comes with a host of\nadvantages, including type coercion when necessary. In this simple\ncase it looks like this:</p>\n<pre><code>>>> \"%s%s%s\" % (str1, str2, str3)\n'abcdefghi'\n</code></pre>\n<p>Finally, there's the join method available on every string. This\nmethod takes a list of strings and joins them together with the\ncalling string in between each element. If this method is called from\nthe empty string, the elements of the list are joined with nothing\nbetween them. For example:</p>\n<pre><code>>>> ''.join([str1, str2, str3])\n'abcdefghi'\n>>> ', '.join([str1, str2, str3])\n'abc, def, ghi'\n</code></pre>\n<p>If we want to write idiomatic python, we're\n<a href=\"http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#building-strings-from-substrings\">advised against</a>\nusing the addition method in favor of using join. String formatting is\nnot mentioned. Presumably, the flexibility of the formatting system is\noverkill for such a simple application. This is easy enough to test\nthough, so let's see how the performance compares on a common\napplication, say building a url with a username and some kind of id\nnumber.</p>\n<pre><code>def join_test(s, i):\n    return ''.join(['/user/', s, '/', str(i), '/'])\n\ndef format_test(s, i):\n    return \"/user/%s/%i/\" % (s, i)\n\ndef plus_test(s, i):\n    return '/user/' + s + '/' + str(i) + '/'\n</code></pre>\n<p>Now we just need to use Python's timeit module to build some\ntimers. When the timer's timeit method is called, it will run\nits function 1,000,000 times and report how long it took.</p>\n<pre><code>import timeit\n\njointimer = timeit.Timer(\"string_test.join_test('test', 5)\", \"import string_test\")\nprint \"Join method took %f seconds\" % jointimer.timeit()\n\nformattimer = timeit.Timer(\"string_test.format_test('test', 5)\", \"import string_test\")\nprint \"Format method took %f seconds\" % formattimer.timeit()\n\nplustimer = timeit.Timer(\"string_test.plus_test('test', 5)\", \"import string_test\")\nprint \"Plus method took %f seconds\" % plustimer.timeit()\n</code></pre>\n<p>Simple enough, right? Let's look at the results.</p>\n<pre><code>Join method took 1.115780 seconds\nFormat method took 1.275534 seconds\nPlus method took 0.756690 seconds    \n</code></pre>\n<p>Whoa! Now here's where I got confused. It turns out the much-maligned\n\"plus\" method of string concatenation is actually the fastest by a\npretty wide margin. Has it been improved considerably since the Python\nidioms were determined or am I just doing something wrong? Occam's\nrazor would suggest that I'm doing something wrong. Let's look more\nclosely at the idiom and figure out what's different.</p>\n<blockquote>\n<p>Start with a list of strings:\ncolors = ['red', 'blue', 'green', 'yellow']\nWe want to join all the strings together into one large string. Especially when the number of substrings is large...\nDon't do this:</p>\n</blockquote>\n<pre><code>result = ''\nfor s in colors:\n    result += s\n</code></pre>\n<blockquote>\n<p>This is very inefficient.\nIt has terrible memory usage and performance patterns. The \"summation\" will compute, store, and then throw away each intermediate step.\nInstead, do this:</p>\n</blockquote>\n<pre><code>result = ''.join(colors)\n</code></pre>\n<blockquote>\n<p>The join() string method does all the copying in one pass.</p>\n</blockquote>\n<p>Well, for one thing, the usage we're being warned about here is a list\nof strings being summed by a loop. Let's add another test that matches\nthat scenario exactly and see how it performs.</p>\n<pre><code>def loop_test(s, i):\n    l = ['/user/', s, '/', str(i), '/']\n    result = ''\n    for s in l:\n        result += s\n    return result\n\nlooptimer = timeit.Timer(\"string_test.loop_test('test', 5)\", \"import string_test\")\nprint \"Loop method took %f seconds\" % looptimer.timeit()\n</code></pre>\n<p>And the result:</p>\n<pre><code>Loop method took 1.427076 seconds    \n</code></pre>\n<p>Now, that makes more sense. The overhead of the loop adds to the time\nconsiderably. In fact, if we modify the plus_test function to add the\noverhead of making a list, this alone accounts for a large portion of\nthe difference in performance.</p>\n<pre><code>def plus_test(s, i):\n    l = ['/user/', s, '/', str(i), '/']\n    return '/user/' + s + '/' + str(i) + '/'    \n\nPlus method took 1.259691 seconds\n</code></pre>\n<p>So, if you can avoid building a list and just sum the strings together\ndirectly, this is the fastest way to concatenate them. However,\nif they're already in a list, using join is your best bet. The format\nmethod is pretty slow even without the overhead of making a list, but\nit's probably going to be a bit more readable when there's multiple\nsubstitutions with different types involved.</p>\n<p>Of course, you should always profile your code to see where the\nbottlenecks are before making any changes. If you're starting from\nscratch though, it doesn't hurt to use the fastest method available.</p>\n<p><em>Originally published 2010-03-01 10:42:41</em></p>","frontmatter":{"date":"2010-03-01","path":"/gdarchive/7","title":"The Python String Concatenation Shootout"}},"site":{"siteMetadata":{"title":"KotSF"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}